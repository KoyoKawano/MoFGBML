package cilabo.gbml.component.variation;

import java.util.ArrayList;
import java.util.List;

import org.apache.commons.lang3.tuple.Pair;
import org.uma.jmetal.component.variation.Variation;
import org.uma.jmetal.operator.crossover.CrossoverOperator;
import org.uma.jmetal.operator.mutation.MutationOperator;
import org.uma.jmetal.solution.Solution;
import org.uma.jmetal.solution.integersolution.IntegerSolution;
import org.uma.jmetal.util.JMetalException;
import org.uma.jmetal.util.pseudorandom.BoundedRandomGenerator;

import cilabo.data.DataSet;
import cilabo.data.Pattern;
import cilabo.fuzzy.classifier.operator.classification.factory.SingleWinnerRuleSelection;
import cilabo.fuzzy.knowledge.Knowledge;
import cilabo.fuzzy.rule.antecedent.Antecedent;
import cilabo.fuzzy.rule.consequent.ConsequentFactory;
import cilabo.gbml.objectivefunction.impl.ErrorRateForPittsburgh;
import cilabo.gbml.operator.heuristic.ruleGeneration.PatternBaseRuleGeneration;
import cilabo.gbml.solution.MichiganSolution;
import cilabo.gbml.solution.PittsburghSolution;
import cilabo.gbml.solution.util.attribute.ErroredPatternsAttribute;
import cilabo.main.Consts;
import cilabo.utility.GeneralFunctions;
import cilabo.utility.Random;


/*
 * ヒューリスティックルール生成を用いたMichigan型FGBMLの交叉・突然変異をまとめたクラス
 * variateはヒューリスティックルール生成およびGAで生成された個体群を返す．
 * variate() line97 のキャストでエラーが出ます．
 * */
public class MichiganHeuristicVariation <S extends Solution<?>> implements Variation<S> {

	private CrossoverOperator<S> crossover;
	private MutationOperator<S> mutation;
	private int matingPoolSize;
	private int offspringPopulationSize;
	private Knowledge knowledge;
	private ConsequentFactory consequentFactory;
	private PatternBaseRuleGeneration ruleGenerateOperator;
	BoundedRandomGenerator<Integer> selectRandomGenerator;


	public MichiganHeuristicVariation(
			int offspringPopulationSize,
			CrossoverOperator<S> crossover,
			MutationOperator<S> mutation,
			Knowledge knowledge,
			ConsequentFactory consequentFactory,
			PatternBaseRuleGeneration ruleGenerateOperator)
	{
		this.crossover = crossover;
		this.mutation = mutation;
		this.offspringPopulationSize = offspringPopulationSize;

		this.matingPoolSize = offspringPopulationSize *
				crossover.getNumberOfRequiredParents() / crossover.getNumberOfGeneratedChildren();
		int remainder = matingPoolSize % crossover.getNumberOfRequiredParents();
		if (remainder != 0) {
			matingPoolSize += remainder;
		}
		this.knowledge = knowledge;
		this.consequentFactory = consequentFactory;
		this.ruleGenerateOperator = ruleGenerateOperator;
	}

	public MichiganHeuristicVariation(
			int offspringPopulationSize,
			CrossoverOperator<S> crossover,
			MutationOperator<S> mutation,
			Knowledge knowledge,
			ConsequentFactory consequentFactory,
			PatternBaseRuleGeneration ruleGenerateOperator,
			BoundedRandomGenerator<Integer> selectRandomGenerator)
	{
		this.crossover = crossover;
		this.mutation = mutation;
		this.offspringPopulationSize = offspringPopulationSize;

		this.matingPoolSize = offspringPopulationSize *
				crossover.getNumberOfRequiredParents() / crossover.getNumberOfGeneratedChildren();
		int remainder = matingPoolSize % crossover.getNumberOfRequiredParents();
		if (remainder != 0) {
			matingPoolSize += remainder;
		}
		this.knowledge = knowledge;
		this.consequentFactory = consequentFactory;
		this.ruleGenerateOperator = ruleGenerateOperator;
		this.selectRandomGenerator = selectRandomGenerator;
	}

	@SuppressWarnings("unchecked")
	@Override
	public List<S> variate(List<S> population, List<S> matingPopulation){

		List<Pair<Integer, Integer>> bounds = new ArrayList<>();
		for(int i = 0; i < population.size() * knowledge.getDimension(); i++) {
			bounds.add(Pair.of(0, knowledge.getFuzzySetNum(0)));
		}
		PittsburghSolution parent = new PittsburghSolution(bounds,
															1,
															(List<IntegerSolution>) population,
															new SingleWinnerRuleSelection());

		DataSet train = consequentFactory.getTrain();

		new ErrorRateForPittsburgh(train).function(parent);

		List<S> generatedMichiganSolution = new ArrayList<>();

		/* Step 1. Calculate number of all of generating rules. */
		int numberOfGeneratingRules = Consts.RULE_CHANGE_NUM;

		/* Step 2. Calculate numbers of rules generated by GA and Heuristic rule generation method. */
		int numberOfHeuristic;
		if(numberOfGeneratingRules % 2 == 0) {
			numberOfHeuristic = numberOfGeneratingRules / 2;
		}
		else {
			int plus = selectRandomGenerator.getRandomValue(0, 1);
			numberOfHeuristic = (numberOfGeneratingRules - 1) / 2 + plus;
		}

		/* Step 3. Heuristic Rule Generation */
		if(numberOfHeuristic > 0) {
			List<Integer> erroredPatterns = (List<Integer>)parent.getAttribute((new ErroredPatternsAttribute<IntegerSolution>()).getAttributeId());
			//誤識別パターンが足りないor無い場合は，ランダムなパターンをリストに追加
			int NumberOfLack = numberOfHeuristic - erroredPatterns.size();
			for(int i = 0; i < NumberOfLack; i++) {
				int id = train.getPattern(Random.getInstance().getGEN()
						.nextInt(train.getDataSize()))
						.getID();
				erroredPatterns.add(id);
			}

			//Sampling patterns without replacement from erroredPatterns.
			Integer[] erroredPatternsIdx = GeneralFunctions.samplingWithout(erroredPatterns.size(),
					numberOfHeuristic,
					Random.getInstance().getGEN());

			for(int i = 0; i < erroredPatternsIdx.length; i++) {
				Pattern pattern = train.getPatternWithID(erroredPatterns.get(erroredPatternsIdx[i]));

				Antecedent generatedAntecedent = ruleGenerateOperator.ruleGenerate(pattern);
				MichiganSolution michiganSolution = new MichiganSolution((MichiganSolution)parent.getMichiganPopulation().get(0));

				for(int n = 0; n < generatedAntecedent.getDimension(); n++) {
					michiganSolution.setVariable(n, generatedAntecedent.getAntecedentIndexAt(n));
				}

			}
		}

		/* Step 4. Rule Generation by Genetic Algorithm - Michigan-style GA */
		int NumberOfGA = numberOfGeneratingRules - numberOfHeuristic;
		if(NumberOfGA > 0) {
			/* == GA START == */
			/* Offspring Generation */
			List<S> generatedSolutionByGA = new ArrayList<>();
			int numberOfParents = crossover.getNumberOfRequiredParents();
			checkNumberOfParents(matingPopulation, numberOfParents);

			for(int i = 0; i < matingPoolSize; i+= numberOfParents) {
				List<S> parents = new ArrayList<>();
				for(int j = 0; j < numberOfParents; j++) {
					parents.add(matingPopulation.get(i + j));
				}

				/* Crossover */
				List<S> offspring = crossover.execute(parents);
				/* Mutation */
				for(S s : offspring) {
					mutation.execute(s);
					generatedSolutionByGA.add(s);
					if(generatedSolutionByGA.size() == NumberOfGA) {
						break;
					}
				}
			}
			/* == GA END == */
			// Merge rules (generated by Heuristic) and rules (generated by GA)
			generatedMichiganSolution.addAll(generatedSolutionByGA);
		}

		//Learning
		for(S s: generatedMichiganSolution) {
			((MichiganSolution)s).learning(knowledge, consequentFactory);
		}

		return generatedMichiganSolution;

	}

	/**
	 * A crossover operator is applied to a number of parents, and it assumed that the population contains
	 * a valid number of population. This method checks that.
	 *
	 * @param population
	 * @param numberOfParentsForCrossover
	 * */
	private void checkNumberOfParents(List<S> population, int numberOfParentsForCrossover) {
		if ((population.size() % numberOfParentsForCrossover) != 0) {
			throw new JMetalException("Wrong number of parents: the remainder if the " +
					"population size (" + population.size() + ") is not divisible by " +
					numberOfParentsForCrossover);
		}
	}

	@Override
	public int getMatingPoolSize() {
		return matingPoolSize ;
		}

	@Override
	public int getOffspringPopulationSize() {
		return offspringPopulationSize ;
	}

}

